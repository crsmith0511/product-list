        // if(queryPrice !== undefined){
        //   if(queryPrice == 'lowest'){
        //     Product.find({category: queryCategory})
        //     .populate('price')
        //     .exec((error, products)=>{
        //       products.price.sort((a, b) => a[sort] - b[sort])
        //       response.send(products.price)
        //     })
        //   } else if (queryPrice == 'higest'){
        //     Product
        //     .find({category: queryCategory})
        //     .sort({price: 'descending'})
        //     .exec((error, products) => {
        //       // Note that we're not sending `count` back at the moment, but in the future we might want to know how many are coming back
        //       Product.count().exec((error, count) => {
        //         if(error){
        //           if (err) throw err
        //         }
        //         response.send(products)
        //       })
        //     })
        //   }
        // }








        router.get('/products', (request, response, next) => {
  const parsedUrl = url.parse(request.originalUrl);
  const { query, sort } = querystring.parse(parsedUrl.query);

  const queryPage = request.query.page
  const queryCategory = request.query.category
  const queryPrice = request.query.price
  // return the first page by default
  const page = request.query.page || 1
  const perPage = 9

  if(!queryPage && !queryCategory && !queryPrice){
      //For pagination use bootstrap
      Product
      .find({})
      .skip((perPage * page) - perPage)
      .limit(perPage)
      .exec((error, products) => {
        // Note that we're not sending `count` back at the moment, but in the future we might want to know how many are coming back
        Product.count().exec((error, count) => {
          if(error){
             return next(error)
          }
          response.send(products)
        })
      })
  }

  if(queryCategory !== undefined){
    if(queryPrice == 'lowest'){
      Product.find({category: queryCategory})
      // .skip((perPage * page) - perPage)
      // .limit(perPage)
      .sort({price: 'ascending'})
      .exec((error, products) => {
        if (products.length == 0){
          response.writeHead(404);	
          return response.end("Could not find products in that category.");
        } else{
          response.send(products)
        }
      })
    } else if (queryPrice == 'highest'){
      Product.find({category: queryCategory})
      // .skip((perPage * page) - perPage)
      // .limit(perPage)
      .sort({price: 'descending'})
      .exec((error, products) => {
        if (products.length == 0){
          response.writeHead(404);	
          return response.end("Could not find products in that category.");
        } else{
          response.send(products)
        }
      })
    }else if (queryPrice !== undefined){
      response.writeHead(400);	
      return response.end("Could not read query search. Must enter lowest or highest.")
    }else {
      Product.find({category: queryCategory})
      // .skip((perPage * page) - perPage)
      // .limit(perPage)
      .exec((error, products) => {
        if (products.length == 0){
          response.writeHead(404);	
          return response.end("Could not find products in that category.");
        } else{
          response.send(products)
        }
      })
    }
  } else if (queryPrice !== undefined){
    if(queryPrice == 'lowest'){
      Product
      .find({})
      .sort({price: 'ascending'})
      // .skip((perPage * page) - perPage)
      .limit(perPage)
      .exec((error, products) => {
        // Note that we're not sending `count` back at the moment, but in the future we might want to know how many are coming back
        Product.count().exec((error, count) => {
          if(error){
            if (err) throw err
          }
          response.send(products)
        })
      })
    }else if (queryPrice == 'highest'){
      Product
      .find({})
      .sort({price: 'descending'})
      // .skip((perPage * page) - perPage)
      .limit(perPage)
      .exec((error, products) => {
        // Note that we're not sending `count` back at the moment, but in the future we might want to know how many are coming back
        Product.count().exec((error, count) => {
          if(error){
            if (err) throw err
          }
          response.send(products)
        })
      })
    } else{
      response.writeHead(400);	
      return response.end("Could not read query search. Must enter lowest or highest.")
    }
  }else{
  //For pagination use bootstrap
    Product
      .find({})
      .skip((perPage * page) - perPage)
      .limit(perPage)
      .exec((error, products) => {
        // Note that we're not sending `count` back at the moment, but in the future we might want to know how many are coming back
        Product.count().exec((error, count) => {
          if(error){
             return next(error)
          }
          response.send(products)
        })
      })
  }
})